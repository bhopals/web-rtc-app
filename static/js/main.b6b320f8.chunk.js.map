{"version":3,"sources":["UsersList.js","MessageBox.js","Chat.js","Container.js","App.js","serviceWorker.js","index.js","avatar.png"],"names":["UsersList","users","toggleConnection","connectedTo","connecting","Grid","Column","width","Card","fluid","Content","header","textAlign","length","List","divided","verticalAlign","size","map","userName","Item","key","floated","Button","onClick","disabled","loading","Image","avatar","src","Header","Segment","MessageBox","messages","message","setMessage","sendMsg","name","Sticky","Comment","Group","sender","text","time","Avatar","Author","Metadata","formatRelative","Date","Text","placeholder","icon","Icon","Input","type","value","onChange","e","target","action","color","configuration","iceServers","url","Chat","connection","updateConnection","channel","updateChannel","useState","socketOpen","setSocketOpen","socketMessages","setSocketMessages","isLoggedIn","setIsLoggedIn","setName","loggingIn","setLoggingIn","setUsers","setConnectedTo","setConnecting","alert","setAlert","connectedRef","useRef","webSocket","messagesRef","setMessages","wsUrl","process","REACT_APP_WEBSOCKET_URL","useEffect","current","WebSocket","onmessage","data","JSON","parse","prev","onclose","close","pop","onLogin","updateUsersList","removeUser","onOffer","onAnswer","onCandidate","closeAlert","send","stringify","user","filter","u","handleDataChannelMessageReceived","userMessages","newMessages","Object","assign","success","loggedIn","title","onConfirm","onCancel","localConnection","RTCPeerConnection","onicecandidate","candidate","ondatachannel","event","console","log","receiveChannel","onopen","warning","confirmBtnBsStyle","offer","setRemoteDescription","RTCSessionDescription","then","createAnswer","answer","setLocalDescription","localDescription","catch","addIceCandidate","RTCIceCandidate","className","as","centered","columns","raised","dataChannel","createDataChannel","onerror","error","createOffer","handleConnection","format","Loader","active","inline","Container","ConnectionConsumer","ChannelConsumer","ConnectionContext","createContext","ChannelContext","Consumer","App","setconnection","setChannel","Provider","conn","chn","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","module","exports"],"mappings":"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","file":"static/js/main.b6b320f8.chunk.js","sourcesContent":["import React from \"react\";\nimport {\n  Grid,\n  Segment,\n  Card,\n  List,\n  Button,\n  Image,\n} from \"semantic-ui-react\";\nimport avatar from \"./avatar.png\";\n\nconst UsersList = ({ users, toggleConnection, connectedTo, connecting }) => {\n  return (\n    <Grid.Column width={5}>\n      <Card fluid>\n        <Card.Content header=\"Online Users\" />\n        <Card.Content textAlign=\"left\">\n          {(users.length && (\n            <List divided verticalAlign=\"middle\" size=\"large\">\n              {users.map(({ userName }) => (\n                <List.Item key={userName}>\n                  <List.Content floated=\"right\">\n                    <Button\n                      onClick={() => {\n                        toggleConnection(userName);\n                      }}\n                      disabled={!!connectedTo && connectedTo !== userName}\n                      loading={connectedTo === userName && connecting}\n                    >\n                      {connectedTo === userName ? \"Disconnect\" : \"Connect\"}\n                    </Button>\n                  </List.Content>\n                  <Image avatar src={avatar} />\n                  <List.Content>\n                    <List.Header>{userName}</List.Header>\n                  </List.Content>\n                </List.Item>\n              ))}\n            </List>\n          )) || <Segment>There are no users Online</Segment>}\n        </Card.Content>\n      </Card>\n    </Grid.Column>\n  );\n};\n\nexport default UsersList;\n","import React from \"react\";\nimport {\n  Header,\n  Icon,\n  Input,\n  Grid,\n  Segment,\n  Card,\n  Sticky,\n  Button,\n  Comment\n} from \"semantic-ui-react\";\nimport { formatRelative } from \"date-fns\";\nimport avatar from \"./avatar.png\";\n\nconst MessageBox = ({ messages, connectedTo, message, setMessage, sendMsg, name }) => {\n  return (\n    <Grid.Column width={11}>\n      <Sticky>\n        <Card fluid>\n          <Card.Content\n            header={\n              !!connectedTo ? connectedTo : \"Not chatting with anyone currently\"\n            }\n          />\n          <Card.Content>\n            {!!connectedTo && messages[connectedTo] ? (\n              <Comment.Group>\n                {messages[connectedTo].map(({ name: sender, message: text, time }) => (\n                  <Comment key={`msg-${name}-${time}`}>\n                    <Comment.Avatar src={avatar} />\n                    <Comment.Content>\n                      <Comment.Author>{sender === name ? 'You' : sender}</Comment.Author>\n                      <Comment.Metadata>\n                        <span>\n                          {formatRelative(new Date(time), new Date())}\n                        </span>\n                      </Comment.Metadata>\n                      <Comment.Text>{text}</Comment.Text>\n                    </Comment.Content>\n                  </Comment>\n                ))}\n              </Comment.Group>\n            ) : (\n              <Segment placeholder>\n                <Header icon>\n                  <Icon name=\"discussions\" />\n                  No messages available yet\n                </Header>\n              </Segment>\n            )}\n            <Input\n              fluid\n              type=\"text\"\n              value={message}\n              onChange={e => setMessage(e.target.value)}\n              placeholder=\"Type message\"\n              action\n            >\n              <input />\n              <Button color=\"teal\" disabled={!message} onClick={sendMsg}>\n                <Icon name=\"send\" />\n                Send Message\n              </Button>\n            </Input>\n          </Card.Content>\n        </Card>\n      </Sticky>\n    </Grid.Column>\n  );\n};\n\nexport default MessageBox;\n","import React, { Fragment, useState, useEffect, useRef } from \"react\";\nimport {\n  Header,\n  Icon,\n  Input,\n  Grid,\n  Segment,\n  Button,\n  Loader,\n} from \"semantic-ui-react\";\nimport SweetAlert from \"react-bootstrap-sweetalert\";\nimport { format } from \"date-fns\";\nimport \"./App.css\";\nimport UsersList from \"./UsersList\";\nimport MessageBox from \"./MessageBox\";\n\n// Use for remote connections\nconst configuration = {\n  iceServers: [{ url: \"stun:stun.1.google.com:19302\" }],\n};\n\n// Use for local connections\n// const configuration = null;\n\nconst Chat = ({ connection, updateConnection, channel, updateChannel }) => {\n  const [socketOpen, setSocketOpen] = useState(false);\n  const [socketMessages, setSocketMessages] = useState([]);\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [name, setName] = useState(\"\");\n  const [loggingIn, setLoggingIn] = useState(false);\n  const [users, setUsers] = useState([]);\n  const [connectedTo, setConnectedTo] = useState(\"\");\n  const [connecting, setConnecting] = useState(false);\n  const [alert, setAlert] = useState(null);\n  const connectedRef = useRef();\n  const webSocket = useRef(null);\n  const [message, setMessage] = useState(\"\");\n  const messagesRef = useRef({});\n  const [messages, setMessages] = useState({});\n  const wsUrl = process.env.REACT_APP_WEBSOCKET_URL || \"ws://localhost:9000\";\n\n  useEffect(() => {\n    webSocket.current = new WebSocket(wsUrl);\n    webSocket.current.onmessage = (message) => {\n      const data = JSON.parse(message.data);\n      setSocketMessages((prev) => [...prev, data]);\n    };\n    webSocket.current.onclose = () => {\n      webSocket.current.close();\n    };\n    return () => webSocket.current.close();\n  }, []);\n\n  useEffect(() => {\n    let data = socketMessages.pop();\n    if (data) {\n      switch (data.type) {\n        case \"connect\":\n          setSocketOpen(true);\n          break;\n        case \"login\":\n          onLogin(data);\n          break;\n        case \"updateUsers\":\n          updateUsersList(data);\n          break;\n        case \"removeUser\":\n          removeUser(data);\n          break;\n        case \"offer\":\n          onOffer(data);\n          break;\n        case \"answer\":\n          onAnswer(data);\n          break;\n        case \"candidate\":\n          onCandidate(data);\n          break;\n        default:\n          break;\n      }\n    }\n  }, [socketMessages]);\n\n  const closeAlert = () => {\n    setAlert(null);\n  };\n\n  const send = (data) => {\n    webSocket.current.send(JSON.stringify(data));\n  };\n\n  const handleLogin = () => {\n    setLoggingIn(true);\n    send({\n      type: \"login\",\n      name,\n    });\n  };\n\n  const updateUsersList = ({ user }) => {\n    setUsers((prev) => [...prev, user]);\n  };\n\n  const removeUser = ({ user }) => {\n    setUsers((prev) => prev.filter((u) => u.userName !== user.userName));\n  };\n\n  const handleDataChannelMessageReceived = ({ data }) => {\n    const message = JSON.parse(data);\n    const { name: user } = message;\n    let messages = messagesRef.current;\n    let userMessages = messages[user];\n    if (userMessages) {\n      userMessages = [...userMessages, message];\n      let newMessages = Object.assign({}, messages, { [user]: userMessages });\n      messagesRef.current = newMessages;\n      setMessages(newMessages);\n    } else {\n      let newMessages = Object.assign({}, messages, { [user]: [message] });\n      messagesRef.current = newMessages;\n      setMessages(newMessages);\n    }\n  };\n\n  const onLogin = ({ success, message, users: loggedIn }) => {\n    setLoggingIn(false);\n    if (success) {\n      setAlert(\n        <SweetAlert\n          success\n          title=\"Success!\"\n          onConfirm={closeAlert}\n          onCancel={closeAlert}\n        >\n          Logged in successfully!\n        </SweetAlert>\n      );\n      setIsLoggedIn(true);\n      setUsers(loggedIn);\n      let localConnection = new RTCPeerConnection(configuration);\n      //when the browser finds an ice candidate we send it to another peer\n      localConnection.onicecandidate = ({ candidate }) => {\n        let connectedTo = connectedRef.current;\n\n        if (candidate && !!connectedTo) {\n          send({\n            name: connectedTo,\n            type: \"candidate\",\n            candidate,\n          });\n        }\n      };\n      localConnection.ondatachannel = (event) => {\n        console.log(\"Data channel is created!\");\n        let receiveChannel = event.channel;\n        receiveChannel.onopen = () => {\n          console.log(\"Data channel is open and ready to be used.\");\n        };\n        receiveChannel.onmessage = handleDataChannelMessageReceived;\n        updateChannel(receiveChannel);\n      };\n      updateConnection(localConnection);\n    } else {\n      setAlert(\n        <SweetAlert\n          warning\n          confirmBtnBsStyle=\"danger\"\n          title=\"Failed\"\n          onConfirm={closeAlert}\n          onCancel={closeAlert}\n        >\n          {message}\n        </SweetAlert>\n      );\n    }\n  };\n\n  //when somebody wants to message us\n  const onOffer = ({ offer, name }) => {\n    setConnectedTo(name);\n    connectedRef.current = name;\n\n    connection\n      .setRemoteDescription(new RTCSessionDescription(offer))\n      .then(() => connection.createAnswer())\n      .then((answer) => connection.setLocalDescription(answer))\n      .then(() =>\n        send({ type: \"answer\", answer: connection.localDescription, name })\n      )\n      .catch((e) => {\n        console.log({ e });\n        setAlert(\n          <SweetAlert\n            warning\n            confirmBtnBsStyle=\"danger\"\n            title=\"Failed\"\n            onConfirm={closeAlert}\n            onCancel={closeAlert}\n          >\n            An error has occurred.\n          </SweetAlert>\n        );\n      });\n  };\n\n  //when another user answers to our offer\n  const onAnswer = ({ answer }) => {\n    connection.setRemoteDescription(new RTCSessionDescription(answer));\n  };\n\n  //when we got ice candidate from another user\n  const onCandidate = ({ candidate }) => {\n    connection.addIceCandidate(new RTCIceCandidate(candidate));\n  };\n\n  //when a user clicks the send message button\n  const sendMsg = () => {\n    const time = format(new Date(), \"yyyy-MM-dd'T'HH:mm:ss.SSSxxx\");\n    let text = { time, message, name };\n    let messages = messagesRef.current;\n    let connectedTo = connectedRef.current;\n    let userMessages = messages[connectedTo];\n    if (messages[connectedTo]) {\n      userMessages = [...userMessages, text];\n      let newMessages = Object.assign({}, messages, {\n        [connectedTo]: userMessages,\n      });\n      messagesRef.current = newMessages;\n      setMessages(newMessages);\n    } else {\n      userMessages = Object.assign({}, messages, { [connectedTo]: [text] });\n      messagesRef.current = userMessages;\n      setMessages(userMessages);\n    }\n    channel.send(JSON.stringify(text));\n    setMessage(\"\");\n  };\n\n  const handleConnection = (name) => {\n    var dataChannelOptions = {\n      reliable: true,\n    };\n\n    let dataChannel = connection.createDataChannel(\"messenger\");\n\n    dataChannel.onerror = (error) => {\n      setAlert(\n        <SweetAlert\n          warning\n          confirmBtnBsStyle=\"danger\"\n          title=\"Failed\"\n          onConfirm={closeAlert}\n          onCancel={closeAlert}\n        >\n          An error has occurred.\n        </SweetAlert>\n      );\n    };\n\n    dataChannel.onmessage = handleDataChannelMessageReceived;\n    updateChannel(dataChannel);\n\n    connection\n      .createOffer()\n      .then((offer) => connection.setLocalDescription(offer))\n      .then(() =>\n        send({ type: \"offer\", offer: connection.localDescription, name })\n      )\n      .catch((e) =>\n        setAlert(\n          <SweetAlert\n            warning\n            confirmBtnBsStyle=\"danger\"\n            title=\"Failed\"\n            onConfirm={closeAlert}\n            onCancel={closeAlert}\n          >\n            An error has occurred.\n          </SweetAlert>\n        )\n      );\n  };\n\n  const toggleConnection = (userName) => {\n    if (connectedRef.current === userName) {\n      setConnecting(true);\n      setConnectedTo(\"\");\n      connectedRef.current = \"\";\n      setConnecting(false);\n    } else {\n      setConnecting(true);\n      setConnectedTo(userName);\n      connectedRef.current = userName;\n      handleConnection(userName);\n      setConnecting(false);\n    }\n  };\n  return (\n    <div className=\"App\">\n      {alert}\n      <Header as=\"h2\" icon>\n        <Icon name=\"users\" />\n        Simple WebRTC Chap App\n      </Header>\n      {(socketOpen && (\n        <Fragment>\n          <Grid centered columns={4}>\n            <Grid.Column>\n              {(!isLoggedIn && (\n                <Input\n                  fluid\n                  disabled={loggingIn}\n                  type=\"text\"\n                  onChange={(e) => setName(e.target.value)}\n                  placeholder=\"Username...\"\n                  action\n                >\n                  <input />\n                  <Button\n                    color=\"teal\"\n                    disabled={!name || loggingIn}\n                    onClick={handleLogin}\n                  >\n                    <Icon name=\"sign-in\" />\n                    Login\n                  </Button>\n                </Input>\n              )) || (\n                <Segment raised textAlign=\"center\" color=\"olive\">\n                  Logged In as: {name}\n                </Segment>\n              )}\n            </Grid.Column>\n          </Grid>\n          <Grid>\n            <UsersList\n              users={users}\n              toggleConnection={toggleConnection}\n              connectedTo={connectedTo}\n              connection={connecting}\n            />\n            <MessageBox\n              messages={messages}\n              connectedTo={connectedTo}\n              message={message}\n              setMessage={setMessage}\n              sendMsg={sendMsg}\n              name={name}\n            />\n          </Grid>\n        </Fragment>\n      )) || (\n        <Loader size=\"massive\" active inline=\"centered\">\n          Loading\n        </Loader>\n      )}\n    </div>\n  );\n};\n\nexport default Chat;\n","import React from \"react\";\nimport Chat from \"./Chat\";\nimport { ConnectionConsumer, ChannelConsumer} from \"./App\";\n\nconst Container = () => {\n  return (\n    <ConnectionConsumer>\n      {({ connection, updateConnection }) => (\n        <ChannelConsumer>\n          {({ channel, updateChannel }) => (\n            <Chat\n              connection={connection}\n              updateConnection={updateConnection}\n              channel={channel}\n              updateChannel={updateChannel}\n            />\n          )}\n        </ChannelConsumer>\n      )}\n    </ConnectionConsumer>\n  );\n};\n\nexport default Container","import React, { useState, createContext } from \"react\";\nimport Container from \"./Container\";\n\n\nconst ConnectionContext = createContext({\n  connection: null,\n  updateConnection: () => {}\n});\nconst ChannelContext = createContext({\n  channel: null,\n  updateChannel: () => {}\n});\n\nconst App = () => {\n  const [connection, setconnection] = useState(null);\n  const [channel, setChannel] = useState(null);\n  const updateConnection = conn => {\n    setconnection(conn);\n  };\n  const updateChannel = chn => {\n    setChannel(chn);\n  };\n  return (\n    <ConnectionContext.Provider value={{ connection, updateConnection }}>\n      <ChannelContext.Provider value={{ channel, updateChannel }}>\n        <Container />\n      </ChannelContext.Provider>\n    </ConnectionContext.Provider>\n  );\n};\n\nexport const ConnectionConsumer = ConnectionContext.Consumer\nexport const ChannelConsumer = ChannelContext.Consumer\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import 'semantic-ui-css/semantic.min.css'\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/avatar.315cf354.png\";"],"sourceRoot":""}